1. #### 进程和线程的区别？

   1、进程是什么？
      是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。
   2、线程又是什么？
       线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。
    在运行时，只是暂用一些计数器、寄存器和栈 。

   Ⅰ 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

   Ⅱ 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

   Ⅲ 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

   Ⅳ 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

2. #### 概述

- ##### 基本特征

  - 并发
  - 共享: 互斥共享和同时共享
  - 虚拟: 时分复用技术(多个进程)和空分复用技术(虚拟内存)
  - 异步:走走停停

- ##### 基本功能

  - 进程管理; 内存管理; 文件管理; 设备管理; 
  - ##### 系统调用: 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

3. #### 进程状态的切换？

   - 就绪状态：等待被调度
   - 运行状态
   - 阻塞状态：等待资源
   - 注意：
     - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
     - 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源**不包括 CPU 时间**，缺少 CPU 时间会从运行态转换为就绪态。

4. #### 进程调度算法

   - 批处理系统：批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间
     - **先来先服务 first-come first-serverd（FCFS）**
     - **短作业优先 shortest job first（SJF）**
     - **最短剩余时间优先 shortest remaining time next（SRTN）**
   - 交互式系统：交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。
     - **时间片轮转**

     - **优先级调度**

     - **多级反馈队列**

       一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

       多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

       每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

       可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

5. #### 进程同步

   - 临界区：对临界资源进行访问的那段代码称为临界区

   - 同步和互斥：

     - 同步：多个进程按一定顺序执行；
     - 互斥：多个进程在同一时刻只有一个进程能进入临界区。

   - 信号量：

     - 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

       - **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
       - **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

       down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

       如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

6. #### 进程通信

- 进程同步与进程通信很容易混淆，它们的区别在于：
  - 进程同步：控制多个进程按一定顺序执行；
  - 进程通信：进程间传输信息。

- 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。
- 管道，通过调用pipe函数创建的。
  - 只支持半双工
  - 只能在父子进程中使用
- FIFO，也称命名管道，去除了管道只能在父子进程中使用的限制。

  - FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
- 消息队列
  - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
  - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
  - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

- 信号量

  - 它是一个计数器，用于为多个进程提供对共享数据对象的访问。

- 共享存储

  - 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

    需要使用信号量用来同步对共享存储的访问。

    多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。

- 套接字

  - 与其它通信机制不同的是，它可用于不同机器间的进程通信。

6. #### 虚拟内存

- 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

  为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

  从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

- 页面置换算法

  - 最佳
  - 最近最久未使用 LRU
  - 最近未使用 NRU
  - 先进先出
  - 时钟

- 分段

  虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

  下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

7. ####　磁盘调度算法
- 读写一个磁盘块的时间的影响因素有：

    - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
    - 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
    - 实际的数据传输时间

    其中，**寻道时间最长**，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

- 先来先服务

    按照磁盘请求的顺序进行调度。

    优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

- 最短寻道时间优先

    优先调度与当前磁头所在磁道距离最近的磁道。

    虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

- 电梯算法

    电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

    电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

    因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

8. #### 死锁

- ##### 定义: 

  - 多个进程因为竞争资源而造成的一种僵局(互相等待),若无外力作用,这些进程将无法推进.

- ##### 必要条件 

  - 互斥条件
  - 不可剥夺
  - 请求且保持
  - 循环等待条件

- ##### 处理策略

  - 鸵鸟策略
  - 预防死锁:破坏死锁产生的四个必要条件
  - 避免死锁:防止系统进入不安全状态;银行家算法
  - 死锁的检测及解除
    - 资源分配图
    - 死锁定理:S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理.
    - 死锁接触: 资源剥夺法; 撤销进程发; 进程回退法

9. 进程和线程切换的代价比较

- **进程切换分两步：**

  **1.切换页目录以使用新的地址空间**

  **2.切换内核栈和硬件上下文**

  对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

- **切换的性能消耗：**

  1、线程上下文切换和进程上下文切换一个**最主要的区别是线程的切换虚拟内存空间依然是相同的**，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

  2、另外一个隐藏的损耗是**上下文的切换会扰乱处理器的缓存机制**。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。



